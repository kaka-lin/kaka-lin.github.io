<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OS on Kaka&#39;s Note</title>
    <link>https://kaka-lin.github.io/tags/os/</link>
    <description>Recent content in OS on Kaka&#39;s Note</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 19 Jul 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://kaka-lin.github.io/tags/os/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[LeetCode] 144 Binary Tree Preorder Traversal</title>
      <link>https://kaka-lin.github.io/2020/06/144_binary_tree_preorder_traversal/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/144_binary_tree_preorder_traversal/</guid>
      <description>144. Binary Tree Preorder Traversal Discription Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
inorder:
root tree -&amp;gt; left tree -&amp;gt; right tree  Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3]  Solution 1: Recursive  Runtime: 32 ms (92.42%) Memory Usage: 13.2 MB (52.73%)  # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.</description>
    </item>
    
    <item>
      <title>[LeetCode] 145 Binary Tree Postorder Traversal</title>
      <link>https://kaka-lin.github.io/2020/06/145_binary_tree_postorder_traversal/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/145_binary_tree_postorder_traversal/</guid>
      <description>145. Binary Tree Postorder Traversal Discription Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
inorder:
left tree -&amp;gt; rigth tree -&amp;gt; root tree  Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1]  Solution 1: Recursive  Runtime: 32 ms (91.82%) Memory Usage: 13 MB (95.36%)  # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.</description>
    </item>
    
    <item>
      <title>[LeetCode] 160 Intersection Of Two Linked List</title>
      <link>https://kaka-lin.github.io/2020/06/160_intersection_of_two_linked_list/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/160_intersection_of_two_linked_list/</guid>
      <description>160. Intersection of Two Linked Lists Discription Write a program to find the node at which the intersection of two singly linked lists begins.
Example: Solution 1: Two Pointers  Runtime: 192ms (91.82%) Memory Usage: 41.8 MB (67.17%)  # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): &amp;quot;&amp;quot;&amp;quot; :type head1, head1: ListNode :rtype: ListNode &amp;quot;&amp;quot;&amp;quot; if headA is None or headB is None: return None ptr_a = headA ptr_b = headB while ptr_a is not ptr_b: ptr_a = headB if ptr_a is None else ptr_a.</description>
    </item>
    
    <item>
      <title>[LeetCode] 167 Two Sum II Input Array Is Sorted</title>
      <link>https://kaka-lin.github.io/2020/06/167_two_sum_ii_input_array_is_sorted/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/167_two_sum_ii_input_array_is_sorted/</guid>
      <description>167. Two Sum II - Input array is sorted Discription Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.
Note:  Your returned answers (both index1 and index2) are not zero-based.</description>
    </item>
    
    <item>
      <title>[LeetCode] 169 Majority Element</title>
      <link>https://kaka-lin.github.io/2020/06/169_majority_element/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/169_majority_element/</guid>
      <description>169. Majority Element Discription Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
Example: Input: [3,2,3] Output: 3 Input: [2,2,1,1,1,2,2] Output: 2  Solution 1: HashMap  Runtime: ms (%) Memory Usage: MB (%)  class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: record = {} for num in nums: if num not in record: record[num] = 1 else: record[num] += 1 return max(record.</description>
    </item>
    
    <item>
      <title>[LeetCode] 191 Number Of 1 Bits</title>
      <link>https://kaka-lin.github.io/2020/06/191_number_of_1_bits/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/191_number_of_1_bits/</guid>
      <description>191. Number of 1 Bits Discription Write a function that takes an unsigned integer and return the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Example: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits. Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits.  Solution 1: Loop and Flip The solution is straight-forward.</description>
    </item>
    
    <item>
      <title>[LeetCode] 202 Happy Number</title>
      <link>https://kaka-lin.github.io/2020/06/202_happy_number/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/202_happy_number/</guid>
      <description>202. Happy Number Discription Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>[LeetCode] 203 Remove Linked List Elements</title>
      <link>https://kaka-lin.github.io/2020/06/203_remove_linked_list_elements/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/203_remove_linked_list_elements/</guid>
      <description>203. Remove Linked List Elements Discription Remove all elements from a linked list of integers that have value val.
Example: Input: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5  Solution: Using dummy node can convenience to treat the special case, like the val appear at head of list and immediately after it.
For example:
Input: 1 -&amp;gt; 1 -&amp;gt; 1 Output: []   Runtime: 72ms (90.70%) Memory Usage: 16.1MB (99.7%)  # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>[LeetCode] 206 Reverse Linked List</title>
      <link>https://kaka-lin.github.io/2020/06/206_reverse_linked_list/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/206_reverse_linked_list/</guid>
      <description>206. Reverse Linked List Discription Reverse a singly linked list.
Example: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL  Solution: ref: https://www.youtube.com/watch?v=MRe3UsRadKw&amp;amp;t=4s
 Runtime: 32 ms (99.15%) Memory Usage: 18.7 MB (21.78%)  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head: ListNode) -&amp;gt; ListNode: if head is None or head.next is None: return head ptr = self.</description>
    </item>
    
    <item>
      <title>[LeetCode] 217 Contains Duplicate</title>
      <link>https://kaka-lin.github.io/2020/06/217_contains_duplicate/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/217_contains_duplicate/</guid>
      <description>217. Contains Duplicate Discription Given an array of integers, find if the array contains any duplicates.
Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
Example: Input: [1,2,3,1] Output: true Input: [1,2,3,4] Output: false Input: [1,1,1,3,3,4,3,2,4,2] Output: true  Solution 1: Hash Table  Runtime: ms (%) Memory Usage: MB (%)  class Solution: def containsDuplicate(self, nums: List[int]) -&amp;gt; bool: array = set() for num in nums: if num in array: return True array.</description>
    </item>
    
    <item>
      <title>[LeetCode] 226 Invert Binary Tree</title>
      <link>https://kaka-lin.github.io/2020/06/226_invert_binary_tree/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/226_invert_binary_tree/</guid>
      <description>226. Invert Binary Tree Discription Invert a binary tree.
Example: Input:
 4 / \ 2 7 / \ / \ 1 3 6 9  Output:
 4 / \ 7 2 / \ / \ 9 6 3 1  Solution 1: Recursion  Runtime: 24 ms (87.55%) Memory Usage: 12.7 MB (100%)  # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>[LeetCode] 234 Palindrome Linked List</title>
      <link>https://kaka-lin.github.io/2020/06/234_palindrome_linked_list/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/234_palindrome_linked_list/</guid>
      <description>234. Palindrome Linked List Discription Given a singly linked list, determine if it is a palindrome.
Example: Input: 1-&amp;gt;2 Output: false Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 Output: true  Follow up: Could you do it in O(n) time and O(1) space?
Solution:  Find the middle of the linked list. Reverse the second half of the linked list. Compare.   Runtime: 76 ms (84.86%) Memory Usage: 23.6 MB (92.34%)  # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>[LeetCode] 236 Lowest Common Ancestor Of A Binary Tree</title>
      <link>https://kaka-lin.github.io/2020/06/236_lowest_common_ancestor_of_a_binary_tree/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/236_lowest_common_ancestor_of_a_binary_tree/</guid>
      <description>236. Lowest Common Ancestor of a Binary Tree Discription Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description>
    </item>
    
    <item>
      <title>[LeetCode] 240 Search A 2d Matrix Ii</title>
      <link>https://kaka-lin.github.io/2020/06/240_search_a_2d_matrix_ii/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/240_search_a_2d_matrix_ii/</guid>
      <description>240. Search a 2D Matrix II Discription Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
 Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Example: Consider the following matrix:
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ]  Given target = 5, return true.</description>
    </item>
    
    <item>
      <title>[LeetCode] 242 Valid Anagram</title>
      <link>https://kaka-lin.github.io/2020/06/242_valid_anagram/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/242_valid_anagram/</guid>
      <description>242. Valid Anagram Discription Given two strings s and t , write a function to determine if t is an anagram of s.
Example: Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false  Solution: Hash Table  Runtime: 48 ms (84.31%) Memory Usage: 13.5 MB  class Solution: def isAnagram(self, s: str, t: str) -&amp;gt; bool: if len(s) != len(t): return False length = len(s) table = {} for i in range(length): if s[i] in table: table[s[i]] += 1 else: table[s[i]] = 1 if t[i] in table: table[t[i]] -= 1 else: table[t[i]] = -1 for key, val in table.</description>
    </item>
    
    <item>
      <title>[LeetCode] 297 Serialize And Deserialize Binar Tree</title>
      <link>https://kaka-lin.github.io/2020/06/297_serialize_and_deserialize_binar_tree/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/297_serialize_and_deserialize_binar_tree/</guid>
      <description>297. Serialize and Deserialize Binary Tree Discription Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.</description>
    </item>
    
    <item>
      <title>[LeetCode] 344 Reverse String</title>
      <link>https://kaka-lin.github.io/2020/06/344_reverse_string/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/344_reverse_string/</guid>
      <description>344. Reverse String Discription Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1: Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;]  Example 2: Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;]  Solution 1: Two Pointers  Runtime: 212 ms (70.</description>
    </item>
    
    <item>
      <title>[LeetCode] 371 Sum Of Two Integers</title>
      <link>https://kaka-lin.github.io/2020/06/371_sum_of_two_integers/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/371_sum_of_two_integers/</guid>
      <description>371. Sum of Two Integers Discription Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example: Input: a = 1, b = 2 Output: 3 Input: a = -2, b = 3 Output: 1 Solution 1: Bit manipulation Ref: https://www.youtube.com/watch?v=qq64FrA2UXQ Explain key point 2 -&amp;gt; 10 3 -&amp;gt; 11 explain with 1 + 3: 11 =&amp;gt; this is</description>
    </item>
    
    <item>
      <title>[LeetCode] 394 Decode String</title>
      <link>https://kaka-lin.github.io/2020/06/394_decode_string/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/394_decode_string/</guid>
      <description>394. Decode String Discription Given an encoded string, return its decoded string.
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.</description>
    </item>
    
    <item>
      <title>[LeetCode] 509 Fibonacci Number</title>
      <link>https://kaka-lin.github.io/2020/06/509_fibonacci_number/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/2020/06/509_fibonacci_number/</guid>
      <description>509. Fibonacci Number Discription Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.  Example 2: Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.  Solution: Top-Down  Runtime: 24 ms (95.55%) Memory Usage: 12.7 MB (100%)  class Solution: def fib(self, N: int) -&amp;gt; int: if N &amp;lt;= 1: return N cache = {0: 0, 1: 1} for i in range(2, N+1): cache[i] = cache[i-1] + cache[i-2] return cache[N]  Time complexity  O(N)  Space complexity  O(N)  </description>
    </item>
    
  </channel>
</rss>
