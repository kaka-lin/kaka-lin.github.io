<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Science on Kaka&#39;s Blog</title>
    <link>https://kaka-lin.github.io/tags/data-science/</link>
    <description>Recent content in Data Science on Kaka&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 10 Jun 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://kaka-lin.github.io/tags/data-science/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Bitonic Champion Problem   Input: A bitonic sequence A[1], A[2], &amp;hellip;, A[n] for distinct positive integers.
  Output: the index $i$ with $1 {\leq} i {\leq} n$ such that
$$A[i] = \max_{1 {\leq} j {\leq} n} A[j]$$
  Bitonic sequence The bitonic sequence means &amp;quot;increasing&amp;quot; before the champion and &amp;quot;decreasing&amp;quot; after the champion  Exmaple
3 7 9 17 35 28 21 18 6 4  Bitonic Champion Problem Complexity   Upper bound: $O(logn)$</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Maximum Subarray Problem   Input: A sequence A[1], A[2], &amp;hellip;, A[n] of integers.
  Output: Two indicex $i$ and $j$ with $1 {\leq} i {\leq} j {\leq} n$ that maximize
$$A[i] + A[i+1] + \cdots + A[j]$$
  Solution 1. Divide and Conquer  Base case (n = 1)  Return itself (maximum subarray)   Recursive case (n &amp;gt; 1)  Divide the array into two sub-arrays Find the maximum sub-array recuresively Merge the result    Bitonic Champion Problem Complexity   Upper bound: $O(n)$</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Merge Sort One of the classic examples of the divide-and-conquer algorithm is the merge sort algorithm. Merge sort is an efficient and general-purpose sorting algorithm. Intuition There are two apporaches to implement the merge sort algorithm: top-down or bottom-up. The merge sort algorithm can be divided into three steps, like all divide-and-conquer algorithms. 1. Divide the given unsorted list into several sublists. (Divide) 2. Sort each of the sublists recursively.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Quick Sort Quick sort is another classical divide-and-conquer algorithm for sorting. Intuition The quick sort algorithm can be implemented in three steps, namely dividing the problem, solving the subproblems and combing the results of subproblems. In detail, given a list of values to sort, the quick sort algorithm works in following steps: First, it selects a value from the list, which serves as a pivot value to divide the list</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Divide and Conquer Solve a problwm recursively
Three steps   Divide
Divide the problem into a number of subproblems that are smaller instances of the same problem.    Conquer
Conquer the subproblems by solving them recursively.    Base case (Termination condition): Solve the subproblems if the subproblem sizes are small enough.
  Recursive case: Recursively solve itself.
    Combine
Combine the solutions to the subproblems into the solution for the original problem.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Tower of Hanoi  Problem: move n disks from A to C Rules:  Move one disk at a time. Cannot place a large dosk onto a smaller disk.    Reference  ADA, NTU CSIE  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Recursion </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/07_methods_interfaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/07_methods_interfaces/</guid>
      <description>Methods and Interfaces Learn how to define methods on types, how to declare interfaces, and how to put everything together. Methods and Interfaces Methods (方法) Example Method on Non-struct type Pointer receivers Choosing a value or pointer receiver Interfaces (介面) Implement methods of an interface Interface values The empty interface Type assertions Type switches Example Methods (方法) Go does not classes.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/08_concurrency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/08_concurrency/</guid>
      <description>Concurrency Go provides concurrency features as part of the core language. This module goes over goroutines and channels, and how they are used to implement different concurrency patterns. 複習: Concurrency and Parallelism Goroutines A goroutine is a lightweight thread managed by Go runtime. goroutine是輕量級的執行緒(lightwe</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Go Learning Notes  01 Go Basics 02 Flow Control 03 Structs 04 Array &amp;amp; Slices 05 Maps 06 Advanced Function 07 Methods and interfaces  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/coroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/coroutine/</guid>
      <description>Coroutine (協程) 先來看一下Wiki上關於Coroutine的解釋: Coroutines are computer program components that generalize subroutines for non-preemptive multitasking (協同運作多工), by allowing execution to be suspended and resumed. 簡單來說，Corouti</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Operate System (OS) I/O Models: 同步、非同步、阻塞、非阻塞 Concurrency(並行) 與 Parallelism(平行) Corotuine(協程)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Papers All papers of my reading
Top Conference CVPR    # Paper Links     1 Learning in the Frequency Domain slides   2 CARS: Contunuous Evolution for Efficient Neural Architecture Search slides   3 High Frequency Component Helps Explain the Generalization of Convolutional Neural Networks slides   4 YUVMultiNet: Real-time YUV multi-task CNN for autonomous driving slides    AAAI    # Paper Links     1 Distance-IoU Loss: Faster and Better Learning for Bounding Box Regression slides   2 Pruning from Scratch slides    ICLR    # Paper Links     1 Once for All: Train One Network and Specialize it for Efficient Deployment slides    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Python Learning Notes Table of Contents 00. Install Python Windows macOS Ubuntu 01. Python Basics 01. Python Basics 02. Flow Control 03. List 04. Dictionary 05. Function 02. Process Management 01. Multithread (多執行緒) 02. Multiprocessing (多程序) 03. Coroutine (協程) 03-1. Generator (生成器)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/01_paint_system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/01_paint_system/</guid>
      <description>Qt&amp;rsquo;s Paint System 初探Qt的繪圖系統 前言 最近因為再研究labeling tool的關係，於是又重新把Qt的繪圖系統重新研究了一下 Qt&amp;rsquo;s Paint System Qt&#39;s paint system enables painting on screen and print devices</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Painting in Qt5 Example of how to render image in Qt or PyQt5
Knowledge  01 Paint System  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Qt/Qml Learning Notes Painting in Qt5</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>Hello React 最近因為專案需要用到，於是又打開了兩年前在Udemy上買的React課程複習， 驚喜的發現講師有Update了2020版本上去，於是打算邊</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>JSX 介紹 首先看看下面這個變數宣告 const element = &amp;lt;h1&amp;gt;你好，世界！&amp;lt;/h1&amp;gt;; 這個有趣的標籤語法不是一個字串也不是HTML。 這</description>
    </item>
    
    <item>
      <title></title>
      <link>https://kaka-lin.github.io/1/01/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kaka-lin.github.io/1/01/readme/</guid>
      <description>React React official website
Learn Notes  01. Hello React 02. Hello JSX  </description>
    </item>
    
  </channel>
</rss>
